// Code generated by sqlc. DO NOT EDIT.
// source: colleaction.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/tabbed/pqtype"
)

const createCollection = `-- name: CreateCollection :one
INSERT INTO collections (
  name, slug, notes, singleton, created_by
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, slug, name, notes, singleton, schema, listrule, viewrule, createrule, updaterule, deleterule, tags, meta, created_by, updated_by, created_at, updated_at
`

type CreateCollectionParams struct {
	Name      sql.NullString `json:"name"`
	Slug      string         `json:"slug"`
	Notes     sql.NullString `json:"notes"`
	Singleton bool           `json:"singleton"`
	CreatedBy uuid.NullUUID  `json:"created_by"`
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (Collection, error) {
	row := q.db.QueryRowContext(ctx, createCollection,
		arg.Name,
		arg.Slug,
		arg.Notes,
		arg.Singleton,
		arg.CreatedBy,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Notes,
		&i.Singleton,
		&i.Schema,
		&i.Listrule,
		&i.Viewrule,
		&i.Createrule,
		&i.Updaterule,
		&i.Deleterule,
		&i.Tags,
		&i.Meta,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCollection = `-- name: DeleteCollection :execresult
DELETE FROM collections
WHERE id = ?
`

func (q *Queries) DeleteCollection(ctx context.Context, id uuid.UUID) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteCollection, id)
}

const getCollection = `-- name: GetCollection :one
SELECT id, slug, name, notes, singleton, schema, listrule, viewrule, createrule, updaterule, deleterule, tags, meta, created_by, updated_by, created_at, updated_at FROM collections
WHERE id = ? LIMIT 1
`

func (q *Queries) GetCollection(ctx context.Context, id uuid.UUID) (Collection, error) {
	row := q.db.QueryRowContext(ctx, getCollection, id)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Notes,
		&i.Singleton,
		&i.Schema,
		&i.Listrule,
		&i.Viewrule,
		&i.Createrule,
		&i.Updaterule,
		&i.Deleterule,
		&i.Tags,
		&i.Meta,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCollectionBySlug = `-- name: GetCollectionBySlug :one
SELECT id, slug, name, notes, singleton, schema, listrule, viewrule, createrule, updaterule, deleterule, tags, meta, created_by, updated_by, created_at, updated_at FROM collections
WHERE slug = ? LIMIT 1
`

func (q *Queries) GetCollectionBySlug(ctx context.Context, slug string) (Collection, error) {
	row := q.db.QueryRowContext(ctx, getCollectionBySlug, slug)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Notes,
		&i.Singleton,
		&i.Schema,
		&i.Listrule,
		&i.Viewrule,
		&i.Createrule,
		&i.Updaterule,
		&i.Deleterule,
		&i.Tags,
		&i.Meta,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCollections = `-- name: ListCollections :many
SELECT id, slug, name, notes, singleton, schema, listrule, viewrule, createrule, updaterule, deleterule, tags, meta, created_by, updated_by, created_at, updated_at FROM collections
ORDER BY name ASC
`

func (q *Queries) ListCollections(ctx context.Context) ([]Collection, error) {
	rows, err := q.db.QueryContext(ctx, listCollections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Collection{}
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Notes,
			&i.Singleton,
			&i.Schema,
			&i.Listrule,
			&i.Viewrule,
			&i.Createrule,
			&i.Updaterule,
			&i.Deleterule,
			&i.Tags,
			&i.Meta,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCollection = `-- name: UpdateCollection :one
UPDATE collections SET name = ?, slug = ?, notes = ?, singleton = ?, schema = ?, listRule = ?, viewRule = ?, createRule = ?, updateRule = ?, deleteRule = ?, tags = ?, meta = ?, updated_at = ?, updated_by = ? 
WHERE id = ?
RETURNING id, slug, name, notes, singleton, schema, listrule, viewrule, createrule, updaterule, deleterule, tags, meta, created_by, updated_by, created_at, updated_at
`

type UpdateCollectionParams struct {
	Name       sql.NullString        `json:"name"`
	Slug       string                `json:"slug"`
	Notes      sql.NullString        `json:"notes"`
	Singleton  bool                  `json:"singleton"`
	Schema     json.RawMessage       `json:"schema"`
	Listrule   sql.NullString        `json:"listrule"`
	Viewrule   sql.NullString        `json:"viewrule"`
	Createrule sql.NullString        `json:"createrule"`
	Updaterule sql.NullString        `json:"updaterule"`
	Deleterule sql.NullString        `json:"deleterule"`
	Tags       pqtype.NullRawMessage `json:"tags"`
	Meta       pqtype.NullRawMessage `json:"meta"`
	UpdatedAt  time.Time             `json:"updated_at"`
	UpdatedBy  uuid.NullUUID         `json:"updated_by"`
	ID         uuid.UUID             `json:"id"`
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) (Collection, error) {
	row := q.db.QueryRowContext(ctx, updateCollection,
		arg.Name,
		arg.Slug,
		arg.Notes,
		arg.Singleton,
		arg.Schema,
		arg.Listrule,
		arg.Viewrule,
		arg.Createrule,
		arg.Updaterule,
		arg.Deleterule,
		arg.Tags,
		arg.Meta,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.ID,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Notes,
		&i.Singleton,
		&i.Schema,
		&i.Listrule,
		&i.Viewrule,
		&i.Createrule,
		&i.Updaterule,
		&i.Deleterule,
		&i.Tags,
		&i.Meta,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
